// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: management/network/v1alpha1/network.proto

package v1alpha1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on NodeNetworkInterface with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NodeNetworkInterface) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeNetworkInterface with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeNetworkInterfaceMultiError, or nil if none found.
func (m *NodeNetworkInterface) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeNetworkInterface) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeNetworkInterfaceValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeNetworkInterfaceValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeNetworkInterfaceValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetNetworkInterface() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeNetworkInterfaceValidationError{
						field:  fmt.Sprintf("NetworkInterface[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeNetworkInterfaceValidationError{
						field:  fmt.Sprintf("NetworkInterface[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeNetworkInterfaceValidationError{
					field:  fmt.Sprintf("NetworkInterface[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodeNetworkInterfaceMultiError(errors)
	}

	return nil
}

// NodeNetworkInterfaceMultiError is an error wrapping multiple validation
// errors returned by NodeNetworkInterface.ValidateAll() if the designated
// constraints aren't met.
type NodeNetworkInterfaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeNetworkInterfaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeNetworkInterfaceMultiError) AllErrors() []error { return m }

// NodeNetworkInterfaceValidationError is the validation error returned by
// NodeNetworkInterface.Validate if the designated constraints aren't met.
type NodeNetworkInterfaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeNetworkInterfaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeNetworkInterfaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeNetworkInterfaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeNetworkInterfaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeNetworkInterfaceValidationError) ErrorName() string {
	return "NodeNetworkInterfaceValidationError"
}

// Error satisfies the builtin error interface
func (e NodeNetworkInterfaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeNetworkInterface.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeNetworkInterfaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeNetworkInterfaceValidationError{}

// Validate checks the field values on MultusConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MultusConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MultusConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MultusConfigMultiError, or
// nil if none found.
func (m *MultusConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *MultusConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetCreationTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MultusConfigValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MultusConfigValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreationTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MultusConfigValidationError{
				field:  "CreationTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MultusConfigValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MultusConfigValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MultusConfigValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MultusConfigValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MultusConfigValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MultusConfigValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MultusConfigMultiError(errors)
	}

	return nil
}

// MultusConfigMultiError is an error wrapping multiple validation errors
// returned by MultusConfig.ValidateAll() if the designated constraints aren't met.
type MultusConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MultusConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MultusConfigMultiError) AllErrors() []error { return m }

// MultusConfigValidationError is the validation error returned by
// MultusConfig.Validate if the designated constraints aren't met.
type MultusConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MultusConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MultusConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MultusConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MultusConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MultusConfigValidationError) ErrorName() string { return "MultusConfigValidationError" }

// Error satisfies the builtin error interface
func (e MultusConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMultusConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MultusConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MultusConfigValidationError{}

// Validate checks the field values on ListNodesNetworkInterfacesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListNodesNetworkInterfacesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodesNetworkInterfacesRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListNodesNetworkInterfacesRequestMultiError, or nil if none found.
func (m *ListNodesNetworkInterfacesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodesNetworkInterfacesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListNodesNetworkInterfacesRequestValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListNodesNetworkInterfacesRequestValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListNodesNetworkInterfacesRequestValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListNodesNetworkInterfacesRequestMultiError(errors)
	}

	return nil
}

// ListNodesNetworkInterfacesRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListNodesNetworkInterfacesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListNodesNetworkInterfacesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodesNetworkInterfacesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodesNetworkInterfacesRequestMultiError) AllErrors() []error { return m }

// ListNodesNetworkInterfacesRequestValidationError is the validation error
// returned by ListNodesNetworkInterfacesRequest.Validate if the designated
// constraints aren't met.
type ListNodesNetworkInterfacesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodesNetworkInterfacesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodesNetworkInterfacesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodesNetworkInterfacesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodesNetworkInterfacesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodesNetworkInterfacesRequestValidationError) ErrorName() string {
	return "ListNodesNetworkInterfacesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodesNetworkInterfacesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodesNetworkInterfacesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodesNetworkInterfacesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodesNetworkInterfacesRequestValidationError{}

// Validate checks the field values on ListNodesNetworkInterfacesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListNodesNetworkInterfacesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNodesNetworkInterfacesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListNodesNetworkInterfacesResponseMultiError, or nil if none found.
func (m *ListNodesNetworkInterfacesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNodesNetworkInterfacesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNodesNetworkInterfacesResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNodesNetworkInterfacesResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNodesNetworkInterfacesResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListNodesNetworkInterfacesResponseValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListNodesNetworkInterfacesResponseValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListNodesNetworkInterfacesResponseValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListNodesNetworkInterfacesResponseMultiError(errors)
	}

	return nil
}

// ListNodesNetworkInterfacesResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListNodesNetworkInterfacesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListNodesNetworkInterfacesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodesNetworkInterfacesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodesNetworkInterfacesResponseMultiError) AllErrors() []error { return m }

// ListNodesNetworkInterfacesResponseValidationError is the validation error
// returned by ListNodesNetworkInterfacesResponse.Validate if the designated
// constraints aren't met.
type ListNodesNetworkInterfacesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodesNetworkInterfacesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodesNetworkInterfacesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodesNetworkInterfacesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodesNetworkInterfacesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodesNetworkInterfacesResponseValidationError) ErrorName() string {
	return "ListNodesNetworkInterfacesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNodesNetworkInterfacesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNodesNetworkInterfacesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodesNetworkInterfacesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodesNetworkInterfacesResponseValidationError{}

// Validate checks the field values on CreateMultusConfigRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateMultusConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateMultusConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateMultusConfigRequestMultiError, or nil if none found.
func (m *CreateMultusConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateMultusConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Nic

	if len(errors) > 0 {
		return CreateMultusConfigRequestMultiError(errors)
	}

	return nil
}

// CreateMultusConfigRequestMultiError is an error wrapping multiple validation
// errors returned by CreateMultusConfigRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateMultusConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateMultusConfigRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateMultusConfigRequestMultiError) AllErrors() []error { return m }

// CreateMultusConfigRequestValidationError is the validation error returned by
// CreateMultusConfigRequest.Validate if the designated constraints aren't met.
type CreateMultusConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateMultusConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateMultusConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateMultusConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateMultusConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateMultusConfigRequestValidationError) ErrorName() string {
	return "CreateMultusConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateMultusConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateMultusConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateMultusConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateMultusConfigRequestValidationError{}

// Validate checks the field values on UpdateMultusConfigRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateMultusConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMultusConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMultusConfigRequestMultiError, or nil if none found.
func (m *UpdateMultusConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMultusConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Nic

	if len(errors) > 0 {
		return UpdateMultusConfigRequestMultiError(errors)
	}

	return nil
}

// UpdateMultusConfigRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateMultusConfigRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateMultusConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMultusConfigRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMultusConfigRequestMultiError) AllErrors() []error { return m }

// UpdateMultusConfigRequestValidationError is the validation error returned by
// UpdateMultusConfigRequest.Validate if the designated constraints aren't met.
type UpdateMultusConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMultusConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMultusConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMultusConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMultusConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMultusConfigRequestValidationError) ErrorName() string {
	return "UpdateMultusConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMultusConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMultusConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMultusConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMultusConfigRequestValidationError{}

// Validate checks the field values on Subnet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Subnet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Subnet with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SubnetMultiError, or nil if none found.
func (m *Subnet) ValidateAll() error {
	return m.validate(true)
}

func (m *Subnet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetCreationTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubnetValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubnetValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreationTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubnetValidationError{
				field:  "CreationTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubnetValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubnetValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubnetValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubnetValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubnetValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubnetValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubnetMultiError(errors)
	}

	return nil
}

// SubnetMultiError is an error wrapping multiple validation errors returned by
// Subnet.ValidateAll() if the designated constraints aren't met.
type SubnetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubnetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubnetMultiError) AllErrors() []error { return m }

// SubnetValidationError is the validation error returned by Subnet.Validate if
// the designated constraints aren't met.
type SubnetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubnetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubnetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubnetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubnetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubnetValidationError) ErrorName() string { return "SubnetValidationError" }

// Error satisfies the builtin error interface
func (e SubnetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubnet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubnetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubnetValidationError{}

// Validate checks the field values on IPPool with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IPPool) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPPool with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in IPPoolMultiError, or nil if none found.
func (m *IPPool) ValidateAll() error {
	return m.validate(true)
}

func (m *IPPool) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetCreationTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IPPoolValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IPPoolValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreationTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IPPoolValidationError{
				field:  "CreationTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IPPoolValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IPPoolValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IPPoolValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IPPoolValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IPPoolValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IPPoolValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return IPPoolMultiError(errors)
	}

	return nil
}

// IPPoolMultiError is an error wrapping multiple validation errors returned by
// IPPool.ValidateAll() if the designated constraints aren't met.
type IPPoolMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPPoolMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPPoolMultiError) AllErrors() []error { return m }

// IPPoolValidationError is the validation error returned by IPPool.Validate if
// the designated constraints aren't met.
type IPPoolValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPPoolValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPPoolValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPPoolValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPPoolValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPPoolValidationError) ErrorName() string { return "IPPoolValidationError" }

// Error satisfies the builtin error interface
func (e IPPoolValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPPool.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPPoolValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPPoolValidationError{}

// Validate checks the field values on SubnetConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SubnetConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubnetConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubnetConfigMultiError, or
// nil if none found.
func (m *SubnetConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *SubnetConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Gateway

	// no validation rules for Subnet

	for idx, item := range m.GetRoutes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubnetConfigValidationError{
						field:  fmt.Sprintf("Routes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubnetConfigValidationError{
						field:  fmt.Sprintf("Routes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubnetConfigValidationError{
					field:  fmt.Sprintf("Routes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubnetConfigMultiError(errors)
	}

	return nil
}

// SubnetConfigMultiError is an error wrapping multiple validation errors
// returned by SubnetConfig.ValidateAll() if the designated constraints aren't met.
type SubnetConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubnetConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubnetConfigMultiError) AllErrors() []error { return m }

// SubnetConfigValidationError is the validation error returned by
// SubnetConfig.Validate if the designated constraints aren't met.
type SubnetConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubnetConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubnetConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubnetConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubnetConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubnetConfigValidationError) ErrorName() string { return "SubnetConfigValidationError" }

// Error satisfies the builtin error interface
func (e SubnetConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubnetConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubnetConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubnetConfigValidationError{}

// Validate checks the field values on IPPoolConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IPPoolConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPPoolConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IPPoolConfigMultiError, or
// nil if none found.
func (m *IPPoolConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *IPPoolConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Gateway

	// no validation rules for Subnet

	for idx, item := range m.GetRoutes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IPPoolConfigValidationError{
						field:  fmt.Sprintf("Routes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IPPoolConfigValidationError{
						field:  fmt.Sprintf("Routes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IPPoolConfigValidationError{
					field:  fmt.Sprintf("Routes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IPPoolConfigMultiError(errors)
	}

	return nil
}

// IPPoolConfigMultiError is an error wrapping multiple validation errors
// returned by IPPoolConfig.ValidateAll() if the designated constraints aren't met.
type IPPoolConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPPoolConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPPoolConfigMultiError) AllErrors() []error { return m }

// IPPoolConfigValidationError is the validation error returned by
// IPPoolConfig.Validate if the designated constraints aren't met.
type IPPoolConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPPoolConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPPoolConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPPoolConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPPoolConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPPoolConfigValidationError) ErrorName() string { return "IPPoolConfigValidationError" }

// Error satisfies the builtin error interface
func (e IPPoolConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPPoolConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPPoolConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPPoolConfigValidationError{}

// Validate checks the field values on CreateSubnetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSubnetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSubnetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSubnetRequestMultiError, or nil if none found.
func (m *CreateSubnetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSubnetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSubnetRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSubnetRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSubnetRequestValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSubnetRequestMultiError(errors)
	}

	return nil
}

// CreateSubnetRequestMultiError is an error wrapping multiple validation
// errors returned by CreateSubnetRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateSubnetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSubnetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSubnetRequestMultiError) AllErrors() []error { return m }

// CreateSubnetRequestValidationError is the validation error returned by
// CreateSubnetRequest.Validate if the designated constraints aren't met.
type CreateSubnetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSubnetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSubnetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSubnetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSubnetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSubnetRequestValidationError) ErrorName() string {
	return "CreateSubnetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSubnetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSubnetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSubnetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSubnetRequestValidationError{}

// Validate checks the field values on UpdateSubnetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSubnetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSubnetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSubnetRequestMultiError, or nil if none found.
func (m *UpdateSubnetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSubnetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateSubnetRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateSubnetRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateSubnetRequestValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateSubnetRequestMultiError(errors)
	}

	return nil
}

// UpdateSubnetRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateSubnetRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateSubnetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSubnetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSubnetRequestMultiError) AllErrors() []error { return m }

// UpdateSubnetRequestValidationError is the validation error returned by
// UpdateSubnetRequest.Validate if the designated constraints aren't met.
type UpdateSubnetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSubnetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSubnetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSubnetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSubnetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSubnetRequestValidationError) ErrorName() string {
	return "UpdateSubnetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSubnetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSubnetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSubnetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSubnetRequestValidationError{}

// Validate checks the field values on CreateIPPoolRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateIPPoolRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateIPPoolRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateIPPoolRequestMultiError, or nil if none found.
func (m *CreateIPPoolRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateIPPoolRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateIPPoolRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateIPPoolRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateIPPoolRequestValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateIPPoolRequestMultiError(errors)
	}

	return nil
}

// CreateIPPoolRequestMultiError is an error wrapping multiple validation
// errors returned by CreateIPPoolRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateIPPoolRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateIPPoolRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateIPPoolRequestMultiError) AllErrors() []error { return m }

// CreateIPPoolRequestValidationError is the validation error returned by
// CreateIPPoolRequest.Validate if the designated constraints aren't met.
type CreateIPPoolRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateIPPoolRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateIPPoolRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateIPPoolRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateIPPoolRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateIPPoolRequestValidationError) ErrorName() string {
	return "CreateIPPoolRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateIPPoolRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateIPPoolRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateIPPoolRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateIPPoolRequestValidationError{}

// Validate checks the field values on UpdateIPPoolRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateIPPoolRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIPPoolRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateIPPoolRequestMultiError, or nil if none found.
func (m *UpdateIPPoolRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIPPoolRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateIPPoolRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateIPPoolRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateIPPoolRequestValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateIPPoolRequestMultiError(errors)
	}

	return nil
}

// UpdateIPPoolRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateIPPoolRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateIPPoolRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIPPoolRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIPPoolRequestMultiError) AllErrors() []error { return m }

// UpdateIPPoolRequestValidationError is the validation error returned by
// UpdateIPPoolRequest.Validate if the designated constraints aren't met.
type UpdateIPPoolRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIPPoolRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIPPoolRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIPPoolRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIPPoolRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIPPoolRequestValidationError) ErrorName() string {
	return "UpdateIPPoolRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateIPPoolRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIPPoolRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIPPoolRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIPPoolRequestValidationError{}

// Validate checks the field values on DeleteMultusConfigRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteMultusConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMultusConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMultusConfigRequestMultiError, or nil if none found.
func (m *DeleteMultusConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMultusConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return DeleteMultusConfigRequestMultiError(errors)
	}

	return nil
}

// DeleteMultusConfigRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteMultusConfigRequest.ValidateAll() if the
// designated constraints aren't met.
type DeleteMultusConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMultusConfigRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMultusConfigRequestMultiError) AllErrors() []error { return m }

// DeleteMultusConfigRequestValidationError is the validation error returned by
// DeleteMultusConfigRequest.Validate if the designated constraints aren't met.
type DeleteMultusConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMultusConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMultusConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMultusConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMultusConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMultusConfigRequestValidationError) ErrorName() string {
	return "DeleteMultusConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteMultusConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMultusConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMultusConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMultusConfigRequestValidationError{}

// Validate checks the field values on DeleteMultusConfigResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteMultusConfigResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMultusConfigResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMultusConfigResponseMultiError, or nil if none found.
func (m *DeleteMultusConfigResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMultusConfigResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteMultusConfigResponseMultiError(errors)
	}

	return nil
}

// DeleteMultusConfigResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteMultusConfigResponse.ValidateAll() if
// the designated constraints aren't met.
type DeleteMultusConfigResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMultusConfigResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMultusConfigResponseMultiError) AllErrors() []error { return m }

// DeleteMultusConfigResponseValidationError is the validation error returned
// by DeleteMultusConfigResponse.Validate if the designated constraints aren't met.
type DeleteMultusConfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMultusConfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMultusConfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMultusConfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMultusConfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMultusConfigResponseValidationError) ErrorName() string {
	return "DeleteMultusConfigResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteMultusConfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMultusConfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMultusConfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMultusConfigResponseValidationError{}

// Validate checks the field values on DeleteSubnetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSubnetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSubnetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSubnetRequestMultiError, or nil if none found.
func (m *DeleteSubnetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSubnetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return DeleteSubnetRequestMultiError(errors)
	}

	return nil
}

// DeleteSubnetRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteSubnetRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteSubnetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSubnetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSubnetRequestMultiError) AllErrors() []error { return m }

// DeleteSubnetRequestValidationError is the validation error returned by
// DeleteSubnetRequest.Validate if the designated constraints aren't met.
type DeleteSubnetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSubnetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSubnetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSubnetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSubnetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSubnetRequestValidationError) ErrorName() string {
	return "DeleteSubnetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSubnetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSubnetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSubnetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSubnetRequestValidationError{}

// Validate checks the field values on DeleteSubnetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSubnetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSubnetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSubnetResponseMultiError, or nil if none found.
func (m *DeleteSubnetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSubnetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteSubnetResponseMultiError(errors)
	}

	return nil
}

// DeleteSubnetResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteSubnetResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteSubnetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSubnetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSubnetResponseMultiError) AllErrors() []error { return m }

// DeleteSubnetResponseValidationError is the validation error returned by
// DeleteSubnetResponse.Validate if the designated constraints aren't met.
type DeleteSubnetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSubnetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSubnetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSubnetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSubnetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSubnetResponseValidationError) ErrorName() string {
	return "DeleteSubnetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSubnetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSubnetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSubnetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSubnetResponseValidationError{}

// Validate checks the field values on DeleteIPPoolRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteIPPoolRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteIPPoolRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteIPPoolRequestMultiError, or nil if none found.
func (m *DeleteIPPoolRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteIPPoolRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return DeleteIPPoolRequestMultiError(errors)
	}

	return nil
}

// DeleteIPPoolRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteIPPoolRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteIPPoolRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteIPPoolRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteIPPoolRequestMultiError) AllErrors() []error { return m }

// DeleteIPPoolRequestValidationError is the validation error returned by
// DeleteIPPoolRequest.Validate if the designated constraints aren't met.
type DeleteIPPoolRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteIPPoolRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteIPPoolRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteIPPoolRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteIPPoolRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteIPPoolRequestValidationError) ErrorName() string {
	return "DeleteIPPoolRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteIPPoolRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteIPPoolRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteIPPoolRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteIPPoolRequestValidationError{}

// Validate checks the field values on DeleteIPPoolResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteIPPoolResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteIPPoolResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteIPPoolResponseMultiError, or nil if none found.
func (m *DeleteIPPoolResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteIPPoolResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteIPPoolResponseMultiError(errors)
	}

	return nil
}

// DeleteIPPoolResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteIPPoolResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteIPPoolResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteIPPoolResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteIPPoolResponseMultiError) AllErrors() []error { return m }

// DeleteIPPoolResponseValidationError is the validation error returned by
// DeleteIPPoolResponse.Validate if the designated constraints aren't met.
type DeleteIPPoolResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteIPPoolResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteIPPoolResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteIPPoolResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteIPPoolResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteIPPoolResponseValidationError) ErrorName() string {
	return "DeleteIPPoolResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteIPPoolResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteIPPoolResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteIPPoolResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteIPPoolResponseValidationError{}

// Validate checks the field values on ListMultusConfigsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMultusConfigsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMultusConfigsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMultusConfigsRequestMultiError, or nil if none found.
func (m *ListMultusConfigsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMultusConfigsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListMultusConfigsRequestValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListMultusConfigsRequestValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListMultusConfigsRequestValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListMultusConfigsRequestMultiError(errors)
	}

	return nil
}

// ListMultusConfigsRequestMultiError is an error wrapping multiple validation
// errors returned by ListMultusConfigsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListMultusConfigsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMultusConfigsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMultusConfigsRequestMultiError) AllErrors() []error { return m }

// ListMultusConfigsRequestValidationError is the validation error returned by
// ListMultusConfigsRequest.Validate if the designated constraints aren't met.
type ListMultusConfigsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMultusConfigsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMultusConfigsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMultusConfigsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMultusConfigsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMultusConfigsRequestValidationError) ErrorName() string {
	return "ListMultusConfigsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListMultusConfigsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMultusConfigsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMultusConfigsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMultusConfigsRequestValidationError{}

// Validate checks the field values on ListMultusConfigsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMultusConfigsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMultusConfigsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMultusConfigsResponseMultiError, or nil if none found.
func (m *ListMultusConfigsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMultusConfigsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMultusConfigsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMultusConfigsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMultusConfigsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListMultusConfigsResponseValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListMultusConfigsResponseValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListMultusConfigsResponseValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListMultusConfigsResponseMultiError(errors)
	}

	return nil
}

// ListMultusConfigsResponseMultiError is an error wrapping multiple validation
// errors returned by ListMultusConfigsResponse.ValidateAll() if the
// designated constraints aren't met.
type ListMultusConfigsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMultusConfigsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMultusConfigsResponseMultiError) AllErrors() []error { return m }

// ListMultusConfigsResponseValidationError is the validation error returned by
// ListMultusConfigsResponse.Validate if the designated constraints aren't met.
type ListMultusConfigsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMultusConfigsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMultusConfigsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMultusConfigsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMultusConfigsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMultusConfigsResponseValidationError) ErrorName() string {
	return "ListMultusConfigsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListMultusConfigsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMultusConfigsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMultusConfigsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMultusConfigsResponseValidationError{}

// Validate checks the field values on ListSubnetsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSubnetsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSubnetsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSubnetsRequestMultiError, or nil if none found.
func (m *ListSubnetsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSubnetsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListSubnetsRequestValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListSubnetsRequestValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListSubnetsRequestValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListSubnetsRequestMultiError(errors)
	}

	return nil
}

// ListSubnetsRequestMultiError is an error wrapping multiple validation errors
// returned by ListSubnetsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListSubnetsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSubnetsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSubnetsRequestMultiError) AllErrors() []error { return m }

// ListSubnetsRequestValidationError is the validation error returned by
// ListSubnetsRequest.Validate if the designated constraints aren't met.
type ListSubnetsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSubnetsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSubnetsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSubnetsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSubnetsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSubnetsRequestValidationError) ErrorName() string {
	return "ListSubnetsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListSubnetsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSubnetsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSubnetsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSubnetsRequestValidationError{}

// Validate checks the field values on ListSubnetsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSubnetsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSubnetsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSubnetsResponseMultiError, or nil if none found.
func (m *ListSubnetsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSubnetsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListSubnetsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListSubnetsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListSubnetsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListSubnetsResponseValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListSubnetsResponseValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListSubnetsResponseValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListSubnetsResponseMultiError(errors)
	}

	return nil
}

// ListSubnetsResponseMultiError is an error wrapping multiple validation
// errors returned by ListSubnetsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListSubnetsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSubnetsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSubnetsResponseMultiError) AllErrors() []error { return m }

// ListSubnetsResponseValidationError is the validation error returned by
// ListSubnetsResponse.Validate if the designated constraints aren't met.
type ListSubnetsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSubnetsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSubnetsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSubnetsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSubnetsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSubnetsResponseValidationError) ErrorName() string {
	return "ListSubnetsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListSubnetsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSubnetsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSubnetsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSubnetsResponseValidationError{}

// Validate checks the field values on ListIPPoolsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListIPPoolsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListIPPoolsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListIPPoolsRequestMultiError, or nil if none found.
func (m *ListIPPoolsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListIPPoolsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListIPPoolsRequestValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListIPPoolsRequestValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListIPPoolsRequestValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListIPPoolsRequestMultiError(errors)
	}

	return nil
}

// ListIPPoolsRequestMultiError is an error wrapping multiple validation errors
// returned by ListIPPoolsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListIPPoolsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListIPPoolsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListIPPoolsRequestMultiError) AllErrors() []error { return m }

// ListIPPoolsRequestValidationError is the validation error returned by
// ListIPPoolsRequest.Validate if the designated constraints aren't met.
type ListIPPoolsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListIPPoolsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListIPPoolsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListIPPoolsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListIPPoolsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListIPPoolsRequestValidationError) ErrorName() string {
	return "ListIPPoolsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListIPPoolsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListIPPoolsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListIPPoolsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListIPPoolsRequestValidationError{}

// Validate checks the field values on ListIPPoolsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListIPPoolsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListIPPoolsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListIPPoolsResponseMultiError, or nil if none found.
func (m *ListIPPoolsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListIPPoolsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListIPPoolsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListIPPoolsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListIPPoolsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListIPPoolsResponseValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListIPPoolsResponseValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListIPPoolsResponseValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListIPPoolsResponseMultiError(errors)
	}

	return nil
}

// ListIPPoolsResponseMultiError is an error wrapping multiple validation
// errors returned by ListIPPoolsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListIPPoolsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListIPPoolsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListIPPoolsResponseMultiError) AllErrors() []error { return m }

// ListIPPoolsResponseValidationError is the validation error returned by
// ListIPPoolsResponse.Validate if the designated constraints aren't met.
type ListIPPoolsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListIPPoolsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListIPPoolsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListIPPoolsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListIPPoolsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListIPPoolsResponseValidationError) ErrorName() string {
	return "ListIPPoolsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListIPPoolsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListIPPoolsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListIPPoolsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListIPPoolsResponseValidationError{}

// Validate checks the field values on NodeNetworkInterface_Node with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NodeNetworkInterface_Node) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeNetworkInterface_Node with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeNetworkInterface_NodeMultiError, or nil if none found.
func (m *NodeNetworkInterface_Node) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeNetworkInterface_Node) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return NodeNetworkInterface_NodeMultiError(errors)
	}

	return nil
}

// NodeNetworkInterface_NodeMultiError is an error wrapping multiple validation
// errors returned by NodeNetworkInterface_Node.ValidateAll() if the
// designated constraints aren't met.
type NodeNetworkInterface_NodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeNetworkInterface_NodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeNetworkInterface_NodeMultiError) AllErrors() []error { return m }

// NodeNetworkInterface_NodeValidationError is the validation error returned by
// NodeNetworkInterface_Node.Validate if the designated constraints aren't met.
type NodeNetworkInterface_NodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeNetworkInterface_NodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeNetworkInterface_NodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeNetworkInterface_NodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeNetworkInterface_NodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeNetworkInterface_NodeValidationError) ErrorName() string {
	return "NodeNetworkInterface_NodeValidationError"
}

// Error satisfies the builtin error interface
func (e NodeNetworkInterface_NodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeNetworkInterface_Node.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeNetworkInterface_NodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeNetworkInterface_NodeValidationError{}

// Validate checks the field values on NodeNetworkInterface_NetworkInterface
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *NodeNetworkInterface_NetworkInterface) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeNetworkInterface_NetworkInterface
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// NodeNetworkInterface_NetworkInterfaceMultiError, or nil if none found.
func (m *NodeNetworkInterface_NetworkInterface) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeNetworkInterface_NetworkInterface) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Ip

	// no validation rules for Subnet

	// no validation rules for Gateway

	// no validation rules for State

	if len(errors) > 0 {
		return NodeNetworkInterface_NetworkInterfaceMultiError(errors)
	}

	return nil
}

// NodeNetworkInterface_NetworkInterfaceMultiError is an error wrapping
// multiple validation errors returned by
// NodeNetworkInterface_NetworkInterface.ValidateAll() if the designated
// constraints aren't met.
type NodeNetworkInterface_NetworkInterfaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeNetworkInterface_NetworkInterfaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeNetworkInterface_NetworkInterfaceMultiError) AllErrors() []error { return m }

// NodeNetworkInterface_NetworkInterfaceValidationError is the validation error
// returned by NodeNetworkInterface_NetworkInterface.Validate if the
// designated constraints aren't met.
type NodeNetworkInterface_NetworkInterfaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeNetworkInterface_NetworkInterfaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeNetworkInterface_NetworkInterfaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeNetworkInterface_NetworkInterfaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeNetworkInterface_NetworkInterfaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeNetworkInterface_NetworkInterfaceValidationError) ErrorName() string {
	return "NodeNetworkInterface_NetworkInterfaceValidationError"
}

// Error satisfies the builtin error interface
func (e NodeNetworkInterface_NetworkInterfaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeNetworkInterface_NetworkInterface.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeNetworkInterface_NetworkInterfaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeNetworkInterface_NetworkInterfaceValidationError{}

// Validate checks the field values on SubnetConfig_Route with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubnetConfig_Route) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubnetConfig_Route with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubnetConfig_RouteMultiError, or nil if none found.
func (m *SubnetConfig_Route) ValidateAll() error {
	return m.validate(true)
}

func (m *SubnetConfig_Route) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Dst

	// no validation rules for Gw

	if len(errors) > 0 {
		return SubnetConfig_RouteMultiError(errors)
	}

	return nil
}

// SubnetConfig_RouteMultiError is an error wrapping multiple validation errors
// returned by SubnetConfig_Route.ValidateAll() if the designated constraints
// aren't met.
type SubnetConfig_RouteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubnetConfig_RouteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubnetConfig_RouteMultiError) AllErrors() []error { return m }

// SubnetConfig_RouteValidationError is the validation error returned by
// SubnetConfig_Route.Validate if the designated constraints aren't met.
type SubnetConfig_RouteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubnetConfig_RouteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubnetConfig_RouteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubnetConfig_RouteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubnetConfig_RouteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubnetConfig_RouteValidationError) ErrorName() string {
	return "SubnetConfig_RouteValidationError"
}

// Error satisfies the builtin error interface
func (e SubnetConfig_RouteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubnetConfig_Route.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubnetConfig_RouteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubnetConfig_RouteValidationError{}

// Validate checks the field values on IPPoolConfig_Route with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IPPoolConfig_Route) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IPPoolConfig_Route with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IPPoolConfig_RouteMultiError, or nil if none found.
func (m *IPPoolConfig_Route) ValidateAll() error {
	return m.validate(true)
}

func (m *IPPoolConfig_Route) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Dst

	// no validation rules for Gw

	if len(errors) > 0 {
		return IPPoolConfig_RouteMultiError(errors)
	}

	return nil
}

// IPPoolConfig_RouteMultiError is an error wrapping multiple validation errors
// returned by IPPoolConfig_Route.ValidateAll() if the designated constraints
// aren't met.
type IPPoolConfig_RouteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IPPoolConfig_RouteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IPPoolConfig_RouteMultiError) AllErrors() []error { return m }

// IPPoolConfig_RouteValidationError is the validation error returned by
// IPPoolConfig_Route.Validate if the designated constraints aren't met.
type IPPoolConfig_RouteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IPPoolConfig_RouteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IPPoolConfig_RouteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IPPoolConfig_RouteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IPPoolConfig_RouteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IPPoolConfig_RouteValidationError) ErrorName() string {
	return "IPPoolConfig_RouteValidationError"
}

// Error satisfies the builtin error interface
func (e IPPoolConfig_RouteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIPPoolConfig_Route.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IPPoolConfig_RouteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IPPoolConfig_RouteValidationError{}
