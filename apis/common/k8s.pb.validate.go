// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: common/k8s.proto

package common

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Resources with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Resources) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Resources with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourcesMultiError, or nil
// if none found.
func (m *Resources) ValidateAll() error {
	return m.validate(true)
}

func (m *Resources) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Requests

	// no validation rules for Limits

	if len(errors) > 0 {
		return ResourcesMultiError(errors)
	}

	return nil
}

// ResourcesMultiError is an error wrapping multiple validation errors returned
// by Resources.ValidateAll() if the designated constraints aren't met.
type ResourcesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourcesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourcesMultiError) AllErrors() []error { return m }

// ResourcesValidationError is the validation error returned by
// Resources.Validate if the designated constraints aren't met.
type ResourcesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourcesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourcesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourcesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourcesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourcesValidationError) ErrorName() string { return "ResourcesValidationError" }

// Error satisfies the builtin error interface
func (e ResourcesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResources.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourcesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourcesValidationError{}

// Validate checks the field values on KubeEnv with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KubeEnv) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KubeEnv with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in KubeEnvMultiError, or nil if none found.
func (m *KubeEnv) ValidateAll() error {
	return m.validate(true)
}

func (m *KubeEnv) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Value

	if len(errors) > 0 {
		return KubeEnvMultiError(errors)
	}

	return nil
}

// KubeEnvMultiError is an error wrapping multiple validation errors returned
// by KubeEnv.ValidateAll() if the designated constraints aren't met.
type KubeEnvMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KubeEnvMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KubeEnvMultiError) AllErrors() []error { return m }

// KubeEnvValidationError is the validation error returned by KubeEnv.Validate
// if the designated constraints aren't met.
type KubeEnvValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KubeEnvValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KubeEnvValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KubeEnvValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KubeEnvValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KubeEnvValidationError) ErrorName() string { return "KubeEnvValidationError" }

// Error satisfies the builtin error interface
func (e KubeEnvValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKubeEnv.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KubeEnvValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KubeEnvValidationError{}

// Validate checks the field values on KubeVolume with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KubeVolume) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KubeVolume with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KubeVolumeMultiError, or
// nil if none found.
func (m *KubeVolume) ValidateAll() error {
	return m.validate(true)
}

func (m *KubeVolume) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for MountPath

	// no validation rules for ReadOnly

	if len(errors) > 0 {
		return KubeVolumeMultiError(errors)
	}

	return nil
}

// KubeVolumeMultiError is an error wrapping multiple validation errors
// returned by KubeVolume.ValidateAll() if the designated constraints aren't met.
type KubeVolumeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KubeVolumeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KubeVolumeMultiError) AllErrors() []error { return m }

// KubeVolumeValidationError is the validation error returned by
// KubeVolume.Validate if the designated constraints aren't met.
type KubeVolumeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KubeVolumeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KubeVolumeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KubeVolumeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KubeVolumeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KubeVolumeValidationError) ErrorName() string { return "KubeVolumeValidationError" }

// Error satisfies the builtin error interface
func (e KubeVolumeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKubeVolume.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KubeVolumeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KubeVolumeValidationError{}

// Validate checks the field values on PodConfig with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PodConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PodConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PodConfigMultiError, or nil
// if none found.
func (m *PodConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *PodConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetKubeEnvs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PodConfigValidationError{
						field:  fmt.Sprintf("KubeEnvs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PodConfigValidationError{
						field:  fmt.Sprintf("KubeEnvs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PodConfigValidationError{
					field:  fmt.Sprintf("KubeEnvs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetKubeVolumes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PodConfigValidationError{
						field:  fmt.Sprintf("KubeVolumes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PodConfigValidationError{
						field:  fmt.Sprintf("KubeVolumes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PodConfigValidationError{
					field:  fmt.Sprintf("KubeVolumes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetResources()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PodConfigValidationError{
					field:  "Resources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PodConfigValidationError{
					field:  "Resources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResources()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PodConfigValidationError{
				field:  "Resources",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAffinity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PodConfigValidationError{
					field:  "Affinity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PodConfigValidationError{
					field:  "Affinity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAffinity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PodConfigValidationError{
				field:  "Affinity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SchedulerName

	// no validation rules for PriorityClass

	// no validation rules for Queue

	// no validation rules for TolerationSeconds

	if len(errors) > 0 {
		return PodConfigMultiError(errors)
	}

	return nil
}

// PodConfigMultiError is an error wrapping multiple validation errors returned
// by PodConfig.ValidateAll() if the designated constraints aren't met.
type PodConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PodConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PodConfigMultiError) AllErrors() []error { return m }

// PodConfigValidationError is the validation error returned by
// PodConfig.Validate if the designated constraints aren't met.
type PodConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PodConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PodConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PodConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PodConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PodConfigValidationError) ErrorName() string { return "PodConfigValidationError" }

// Error satisfies the builtin error interface
func (e PodConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPodConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PodConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PodConfigValidationError{}

// Validate checks the field values on Affinity with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Affinity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Affinity with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AffinityMultiError, or nil
// if none found.
func (m *Affinity) ValidateAll() error {
	return m.validate(true)
}

func (m *Affinity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNodeAffinity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AffinityValidationError{
					field:  "NodeAffinity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AffinityValidationError{
					field:  "NodeAffinity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeAffinity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AffinityValidationError{
				field:  "NodeAffinity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPodAffinity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AffinityValidationError{
					field:  "PodAffinity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AffinityValidationError{
					field:  "PodAffinity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPodAffinity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AffinityValidationError{
				field:  "PodAffinity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPodAntiAffinity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AffinityValidationError{
					field:  "PodAntiAffinity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AffinityValidationError{
					field:  "PodAntiAffinity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPodAntiAffinity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AffinityValidationError{
				field:  "PodAntiAffinity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AffinityMultiError(errors)
	}

	return nil
}

// AffinityMultiError is an error wrapping multiple validation errors returned
// by Affinity.ValidateAll() if the designated constraints aren't met.
type AffinityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AffinityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AffinityMultiError) AllErrors() []error { return m }

// AffinityValidationError is the validation error returned by
// Affinity.Validate if the designated constraints aren't met.
type AffinityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AffinityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AffinityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AffinityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AffinityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AffinityValidationError) ErrorName() string { return "AffinityValidationError" }

// Error satisfies the builtin error interface
func (e AffinityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAffinity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AffinityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AffinityValidationError{}

// Validate checks the field values on PodAntiAffinity with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PodAntiAffinity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PodAntiAffinity with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PodAntiAffinityMultiError, or nil if none found.
func (m *PodAntiAffinity) ValidateAll() error {
	return m.validate(true)
}

func (m *PodAntiAffinity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRequiredDuringSchedulingIgnoredDuringExecution() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PodAntiAffinityValidationError{
						field:  fmt.Sprintf("RequiredDuringSchedulingIgnoredDuringExecution[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PodAntiAffinityValidationError{
						field:  fmt.Sprintf("RequiredDuringSchedulingIgnoredDuringExecution[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PodAntiAffinityValidationError{
					field:  fmt.Sprintf("RequiredDuringSchedulingIgnoredDuringExecution[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPreferredDuringSchedulingIgnoredDuringExecution() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PodAntiAffinityValidationError{
						field:  fmt.Sprintf("PreferredDuringSchedulingIgnoredDuringExecution[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PodAntiAffinityValidationError{
						field:  fmt.Sprintf("PreferredDuringSchedulingIgnoredDuringExecution[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PodAntiAffinityValidationError{
					field:  fmt.Sprintf("PreferredDuringSchedulingIgnoredDuringExecution[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PodAntiAffinityMultiError(errors)
	}

	return nil
}

// PodAntiAffinityMultiError is an error wrapping multiple validation errors
// returned by PodAntiAffinity.ValidateAll() if the designated constraints
// aren't met.
type PodAntiAffinityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PodAntiAffinityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PodAntiAffinityMultiError) AllErrors() []error { return m }

// PodAntiAffinityValidationError is the validation error returned by
// PodAntiAffinity.Validate if the designated constraints aren't met.
type PodAntiAffinityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PodAntiAffinityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PodAntiAffinityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PodAntiAffinityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PodAntiAffinityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PodAntiAffinityValidationError) ErrorName() string { return "PodAntiAffinityValidationError" }

// Error satisfies the builtin error interface
func (e PodAntiAffinityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPodAntiAffinity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PodAntiAffinityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PodAntiAffinityValidationError{}

// Validate checks the field values on PodAffinityTerm with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PodAffinityTerm) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PodAffinityTerm with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PodAffinityTermMultiError, or nil if none found.
func (m *PodAffinityTerm) ValidateAll() error {
	return m.validate(true)
}

func (m *PodAffinityTerm) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLabelSelector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PodAffinityTermValidationError{
					field:  "LabelSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PodAffinityTermValidationError{
					field:  "LabelSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLabelSelector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PodAffinityTermValidationError{
				field:  "LabelSelector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TopologyKey

	if all {
		switch v := interface{}(m.GetNamespaceSelector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PodAffinityTermValidationError{
					field:  "NamespaceSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PodAffinityTermValidationError{
					field:  "NamespaceSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNamespaceSelector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PodAffinityTermValidationError{
				field:  "NamespaceSelector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PodAffinityTermMultiError(errors)
	}

	return nil
}

// PodAffinityTermMultiError is an error wrapping multiple validation errors
// returned by PodAffinityTerm.ValidateAll() if the designated constraints
// aren't met.
type PodAffinityTermMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PodAffinityTermMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PodAffinityTermMultiError) AllErrors() []error { return m }

// PodAffinityTermValidationError is the validation error returned by
// PodAffinityTerm.Validate if the designated constraints aren't met.
type PodAffinityTermValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PodAffinityTermValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PodAffinityTermValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PodAffinityTermValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PodAffinityTermValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PodAffinityTermValidationError) ErrorName() string { return "PodAffinityTermValidationError" }

// Error satisfies the builtin error interface
func (e PodAffinityTermValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPodAffinityTerm.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PodAffinityTermValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PodAffinityTermValidationError{}

// Validate checks the field values on LabelSelector with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LabelSelector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LabelSelector with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LabelSelectorMultiError, or
// nil if none found.
func (m *LabelSelector) ValidateAll() error {
	return m.validate(true)
}

func (m *LabelSelector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MatchLabels

	for idx, item := range m.GetMatchExpressions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LabelSelectorValidationError{
						field:  fmt.Sprintf("MatchExpressions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LabelSelectorValidationError{
						field:  fmt.Sprintf("MatchExpressions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LabelSelectorValidationError{
					field:  fmt.Sprintf("MatchExpressions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LabelSelectorMultiError(errors)
	}

	return nil
}

// LabelSelectorMultiError is an error wrapping multiple validation errors
// returned by LabelSelector.ValidateAll() if the designated constraints
// aren't met.
type LabelSelectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabelSelectorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabelSelectorMultiError) AllErrors() []error { return m }

// LabelSelectorValidationError is the validation error returned by
// LabelSelector.Validate if the designated constraints aren't met.
type LabelSelectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabelSelectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabelSelectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabelSelectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabelSelectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabelSelectorValidationError) ErrorName() string { return "LabelSelectorValidationError" }

// Error satisfies the builtin error interface
func (e LabelSelectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabelSelector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabelSelectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabelSelectorValidationError{}

// Validate checks the field values on WeightedPodAffinityTerm with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WeightedPodAffinityTerm) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WeightedPodAffinityTerm with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WeightedPodAffinityTermMultiError, or nil if none found.
func (m *WeightedPodAffinityTerm) ValidateAll() error {
	return m.validate(true)
}

func (m *WeightedPodAffinityTerm) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Weight

	if all {
		switch v := interface{}(m.GetPodAffinityTerm()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WeightedPodAffinityTermValidationError{
					field:  "PodAffinityTerm",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WeightedPodAffinityTermValidationError{
					field:  "PodAffinityTerm",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPodAffinityTerm()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WeightedPodAffinityTermValidationError{
				field:  "PodAffinityTerm",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WeightedPodAffinityTermMultiError(errors)
	}

	return nil
}

// WeightedPodAffinityTermMultiError is an error wrapping multiple validation
// errors returned by WeightedPodAffinityTerm.ValidateAll() if the designated
// constraints aren't met.
type WeightedPodAffinityTermMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WeightedPodAffinityTermMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WeightedPodAffinityTermMultiError) AllErrors() []error { return m }

// WeightedPodAffinityTermValidationError is the validation error returned by
// WeightedPodAffinityTerm.Validate if the designated constraints aren't met.
type WeightedPodAffinityTermValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WeightedPodAffinityTermValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WeightedPodAffinityTermValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WeightedPodAffinityTermValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WeightedPodAffinityTermValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WeightedPodAffinityTermValidationError) ErrorName() string {
	return "WeightedPodAffinityTermValidationError"
}

// Error satisfies the builtin error interface
func (e WeightedPodAffinityTermValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWeightedPodAffinityTerm.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WeightedPodAffinityTermValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WeightedPodAffinityTermValidationError{}

// Validate checks the field values on PodAffinity with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PodAffinity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PodAffinity with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PodAffinityMultiError, or
// nil if none found.
func (m *PodAffinity) ValidateAll() error {
	return m.validate(true)
}

func (m *PodAffinity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRequiredDuringSchedulingIgnoredDuringExecution() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PodAffinityValidationError{
						field:  fmt.Sprintf("RequiredDuringSchedulingIgnoredDuringExecution[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PodAffinityValidationError{
						field:  fmt.Sprintf("RequiredDuringSchedulingIgnoredDuringExecution[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PodAffinityValidationError{
					field:  fmt.Sprintf("RequiredDuringSchedulingIgnoredDuringExecution[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPreferredDuringSchedulingIgnoredDuringExecution() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PodAffinityValidationError{
						field:  fmt.Sprintf("PreferredDuringSchedulingIgnoredDuringExecution[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PodAffinityValidationError{
						field:  fmt.Sprintf("PreferredDuringSchedulingIgnoredDuringExecution[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PodAffinityValidationError{
					field:  fmt.Sprintf("PreferredDuringSchedulingIgnoredDuringExecution[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PodAffinityMultiError(errors)
	}

	return nil
}

// PodAffinityMultiError is an error wrapping multiple validation errors
// returned by PodAffinity.ValidateAll() if the designated constraints aren't met.
type PodAffinityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PodAffinityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PodAffinityMultiError) AllErrors() []error { return m }

// PodAffinityValidationError is the validation error returned by
// PodAffinity.Validate if the designated constraints aren't met.
type PodAffinityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PodAffinityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PodAffinityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PodAffinityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PodAffinityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PodAffinityValidationError) ErrorName() string { return "PodAffinityValidationError" }

// Error satisfies the builtin error interface
func (e PodAffinityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPodAffinity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PodAffinityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PodAffinityValidationError{}

// Validate checks the field values on NodeAffinity with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeAffinity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeAffinity with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeAffinityMultiError, or
// nil if none found.
func (m *NodeAffinity) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeAffinity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRequiredDuringSchedulingIgnoredDuringExecution()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeAffinityValidationError{
					field:  "RequiredDuringSchedulingIgnoredDuringExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeAffinityValidationError{
					field:  "RequiredDuringSchedulingIgnoredDuringExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequiredDuringSchedulingIgnoredDuringExecution()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeAffinityValidationError{
				field:  "RequiredDuringSchedulingIgnoredDuringExecution",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPreferredDuringSchedulingIgnoredDuringExecution() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeAffinityValidationError{
						field:  fmt.Sprintf("PreferredDuringSchedulingIgnoredDuringExecution[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeAffinityValidationError{
						field:  fmt.Sprintf("PreferredDuringSchedulingIgnoredDuringExecution[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeAffinityValidationError{
					field:  fmt.Sprintf("PreferredDuringSchedulingIgnoredDuringExecution[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodeAffinityMultiError(errors)
	}

	return nil
}

// NodeAffinityMultiError is an error wrapping multiple validation errors
// returned by NodeAffinity.ValidateAll() if the designated constraints aren't met.
type NodeAffinityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeAffinityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeAffinityMultiError) AllErrors() []error { return m }

// NodeAffinityValidationError is the validation error returned by
// NodeAffinity.Validate if the designated constraints aren't met.
type NodeAffinityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeAffinityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeAffinityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeAffinityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeAffinityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeAffinityValidationError) ErrorName() string { return "NodeAffinityValidationError" }

// Error satisfies the builtin error interface
func (e NodeAffinityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeAffinity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeAffinityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeAffinityValidationError{}

// Validate checks the field values on NodeSelector with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeSelector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeSelector with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeSelectorMultiError, or
// nil if none found.
func (m *NodeSelector) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeSelector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodeSelectorTerms() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeSelectorValidationError{
						field:  fmt.Sprintf("NodeSelectorTerms[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeSelectorValidationError{
						field:  fmt.Sprintf("NodeSelectorTerms[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeSelectorValidationError{
					field:  fmt.Sprintf("NodeSelectorTerms[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodeSelectorMultiError(errors)
	}

	return nil
}

// NodeSelectorMultiError is an error wrapping multiple validation errors
// returned by NodeSelector.ValidateAll() if the designated constraints aren't met.
type NodeSelectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeSelectorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeSelectorMultiError) AllErrors() []error { return m }

// NodeSelectorValidationError is the validation error returned by
// NodeSelector.Validate if the designated constraints aren't met.
type NodeSelectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeSelectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeSelectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeSelectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeSelectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeSelectorValidationError) ErrorName() string { return "NodeSelectorValidationError" }

// Error satisfies the builtin error interface
func (e NodeSelectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeSelector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeSelectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeSelectorValidationError{}

// Validate checks the field values on PreferredSchedulingTerm with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PreferredSchedulingTerm) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PreferredSchedulingTerm with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PreferredSchedulingTermMultiError, or nil if none found.
func (m *PreferredSchedulingTerm) ValidateAll() error {
	return m.validate(true)
}

func (m *PreferredSchedulingTerm) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Weight

	if all {
		switch v := interface{}(m.GetPreference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PreferredSchedulingTermValidationError{
					field:  "Preference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PreferredSchedulingTermValidationError{
					field:  "Preference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPreference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PreferredSchedulingTermValidationError{
				field:  "Preference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PreferredSchedulingTermMultiError(errors)
	}

	return nil
}

// PreferredSchedulingTermMultiError is an error wrapping multiple validation
// errors returned by PreferredSchedulingTerm.ValidateAll() if the designated
// constraints aren't met.
type PreferredSchedulingTermMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PreferredSchedulingTermMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PreferredSchedulingTermMultiError) AllErrors() []error { return m }

// PreferredSchedulingTermValidationError is the validation error returned by
// PreferredSchedulingTerm.Validate if the designated constraints aren't met.
type PreferredSchedulingTermValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PreferredSchedulingTermValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PreferredSchedulingTermValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PreferredSchedulingTermValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PreferredSchedulingTermValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PreferredSchedulingTermValidationError) ErrorName() string {
	return "PreferredSchedulingTermValidationError"
}

// Error satisfies the builtin error interface
func (e PreferredSchedulingTermValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPreferredSchedulingTerm.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PreferredSchedulingTermValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PreferredSchedulingTermValidationError{}

// Validate checks the field values on NodeSelectorTerm with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NodeSelectorTerm) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeSelectorTerm with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeSelectorTermMultiError, or nil if none found.
func (m *NodeSelectorTerm) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeSelectorTerm) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMatchExpressions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeSelectorTermValidationError{
						field:  fmt.Sprintf("MatchExpressions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeSelectorTermValidationError{
						field:  fmt.Sprintf("MatchExpressions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeSelectorTermValidationError{
					field:  fmt.Sprintf("MatchExpressions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMatchFields() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeSelectorTermValidationError{
						field:  fmt.Sprintf("MatchFields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeSelectorTermValidationError{
						field:  fmt.Sprintf("MatchFields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeSelectorTermValidationError{
					field:  fmt.Sprintf("MatchFields[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NodeSelectorTermMultiError(errors)
	}

	return nil
}

// NodeSelectorTermMultiError is an error wrapping multiple validation errors
// returned by NodeSelectorTerm.ValidateAll() if the designated constraints
// aren't met.
type NodeSelectorTermMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeSelectorTermMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeSelectorTermMultiError) AllErrors() []error { return m }

// NodeSelectorTermValidationError is the validation error returned by
// NodeSelectorTerm.Validate if the designated constraints aren't met.
type NodeSelectorTermValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeSelectorTermValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeSelectorTermValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeSelectorTermValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeSelectorTermValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeSelectorTermValidationError) ErrorName() string { return "NodeSelectorTermValidationError" }

// Error satisfies the builtin error interface
func (e NodeSelectorTermValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeSelectorTerm.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeSelectorTermValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeSelectorTermValidationError{}

// Validate checks the field values on NodeSelectorRequirement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NodeSelectorRequirement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeSelectorRequirement with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeSelectorRequirementMultiError, or nil if none found.
func (m *NodeSelectorRequirement) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeSelectorRequirement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Operator

	if len(errors) > 0 {
		return NodeSelectorRequirementMultiError(errors)
	}

	return nil
}

// NodeSelectorRequirementMultiError is an error wrapping multiple validation
// errors returned by NodeSelectorRequirement.ValidateAll() if the designated
// constraints aren't met.
type NodeSelectorRequirementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeSelectorRequirementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeSelectorRequirementMultiError) AllErrors() []error { return m }

// NodeSelectorRequirementValidationError is the validation error returned by
// NodeSelectorRequirement.Validate if the designated constraints aren't met.
type NodeSelectorRequirementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeSelectorRequirementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeSelectorRequirementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeSelectorRequirementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeSelectorRequirementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeSelectorRequirementValidationError) ErrorName() string {
	return "NodeSelectorRequirementValidationError"
}

// Error satisfies the builtin error interface
func (e NodeSelectorRequirementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeSelectorRequirement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeSelectorRequirementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeSelectorRequirementValidationError{}

// Validate checks the field values on LabelSelectorRequirement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LabelSelectorRequirement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LabelSelectorRequirement with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LabelSelectorRequirementMultiError, or nil if none found.
func (m *LabelSelectorRequirement) ValidateAll() error {
	return m.validate(true)
}

func (m *LabelSelectorRequirement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Operator

	if len(errors) > 0 {
		return LabelSelectorRequirementMultiError(errors)
	}

	return nil
}

// LabelSelectorRequirementMultiError is an error wrapping multiple validation
// errors returned by LabelSelectorRequirement.ValidateAll() if the designated
// constraints aren't met.
type LabelSelectorRequirementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabelSelectorRequirementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabelSelectorRequirementMultiError) AllErrors() []error { return m }

// LabelSelectorRequirementValidationError is the validation error returned by
// LabelSelectorRequirement.Validate if the designated constraints aren't met.
type LabelSelectorRequirementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabelSelectorRequirementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabelSelectorRequirementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabelSelectorRequirementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabelSelectorRequirementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabelSelectorRequirementValidationError) ErrorName() string {
	return "LabelSelectorRequirementValidationError"
}

// Error satisfies the builtin error interface
func (e LabelSelectorRequirementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabelSelectorRequirement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabelSelectorRequirementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabelSelectorRequirementValidationError{}
